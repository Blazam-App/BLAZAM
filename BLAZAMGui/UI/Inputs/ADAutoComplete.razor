@inherits AutoCompleteComponentBase
<MudAutocomplete Class="@Class"
                 Style="@Style"
                 Disabled=@Disabled
                 T="IDirectoryEntryAdapter"
                 Label="@Label"
@bind-Value="SelectedResult"
@bind-Text=@SearchTerm
                 SearchFuncWithCancel="@GetResults"
                 DebounceInterval=500
                 ResetValueOnEmptyText="true"
                 Validation="@Validation"
                 CoerceText="@AllowCustomInput"
                 CoerceValue="false"
                 MaxItems=@MaxResults
                 Clearable=true
                 Dense=true
                 ShowProgressIndicator=true
                 ToStringFunc="item=>item?.CanonicalName"
                 AdornmentColor="Color.Tertiary"
                 ProgressIndicatorColor="Color.Secondary"
                 Adornment="Adornment.Start"
                 AdornmentIcon="@AdornmentIcon"
                 Variant="@Variant">
    <ItemTemplate>
        <ADAutoCompleteResult Entry="context" />

    </ItemTemplate>
    <NoItemsTemplate>
        @if (SearchTerm.IsNullOrEmpty())
        {
            <MudText>

                Start typing to search...
            </MudText>

        }
        else
        {
            <MudText>
                Sorry no result were found 😒
            </MudText>

        }

    </NoItemsTemplate>
    <MoreItemsTemplate>
        <MudText>
            Too many results to show...
        </MudText>
    </MoreItemsTemplate>
</MudAutocomplete>



@code {
#nullable disable warnings
    [Parameter]
    public Func<object> Validation { get; set; }
    [Parameter]
    public string? Label { get; set; }
    [Parameter]
    public string? Style { get; set; }
    [Parameter]
    public Variant Variant { get; set; }
    [Parameter]
    public string? Class { get; set; }
    [Parameter]
    public string AdornmentIcon { get; set; } = Icons.Material.Filled.Search;

    [Parameter]
    public bool Disabled { get; set; }

    [Parameter]
    public int MaxResults { get; set; } = 10;

    [Parameter]
    public bool AllowCustomInput { get; set; }


    [Parameter]
    public Func<IDirectoryEntryAdapter, bool> CustomResultsFilter { get; set; }
    @*
    [Parameter]
    public IFluentDisplay Display { get; set; }*@

    [CascadingParameter]
    public SearchService SearchParameters { get; set; }

    IEnumerable<IDirectoryEntryAdapter> _searchResults = new List<IDirectoryEntryAdapter>();
    bool _searchDisabled;
    [Parameter]
    public bool SearchDisabled
    {
        get => _searchDisabled;
        set
        {
            if (_searchDisabled == value)
                return;
            _searchDisabled = value;
            // SearchDisabledChanged.InvokeAsync(value);
        }
    }


    [Parameter]
    public EventCallback<bool> SearchDisabledChanged { get; set; }


    [Parameter]
    public ActiveDirectoryObjectType? SearchObjectType { get; set; }


    [Parameter]
    public IEnumerable<IDirectoryEntryAdapter> SearchResults
    {
        get => _searchResults;
        set
        {
            if (_searchResults == value)
                return;
            _searchResults = value;
            SearchResultsChanged.InvokeAsync(value);
        }
    }


    [Parameter]
    public EventCallback<IEnumerable<IDirectoryEntryAdapter>> SearchResultsChanged { get; set; }

    public IDirectoryEntryAdapter _selectedResult;
    [Parameter]
    public IDirectoryEntryAdapter SelectedResult
    {
        get => _selectedResult;
        set
        {
            if (_selectedResult == value)
                return;

            SearchResults = new List<IDirectoryEntryAdapter>
                {
                    value
                };
            _selectedResult = value;

            SearchService.SearchTerm = _selectedResult.CanonicalName;

            SelectedResultChanged.InvokeAsync(value);
        }
    }

    [Parameter]
    public EventCallback<IDirectoryEntryAdapter> SelectedResultChanged { get; set; }





    public List<IDirectoryEntryAdapter> _selectedResults;


    List<string> SelectedResultNames = new();




    private async Task<IEnumerable<IDirectoryEntryAdapter>> GetResults(string searchText, CancellationToken token)
    {
        return await Task.Run(() =>
         {

             if (!token.IsCancellationRequested && searchText != null)
             {
                 SearchResults = new List<IDirectoryEntryAdapter>();

                 var search = new ADSearch();

                 search.ObjectTypeFilter = SearchObjectType;
                 search.GeneralSearchTerm = searchText.Replace(" ", "*");
                 search.EnabledOnly = !SearchDisabled;
                 search.MaxResults = MaxResults;
                 if (!search.GeneralSearchTerm.Equals(String.Empty))
                 {
                     var temp = (search.Search<DirectoryEntryAdapter, IDirectoryEntryAdapter>(token)).Where(r => r.CanRead);

                     if (!token.IsCancellationRequested)
                     {

                         if (CustomResultsFilter != null)
                         {
                             List<IDirectoryEntryAdapter> filteredResults = new();
                             foreach (var result in temp)
                             {
                                 if (CustomResultsFilter.Invoke(result))
                                     filteredResults.Add(result);
                             }
                             if (!token.IsCancellationRequested)
                             {
                                 temp = filteredResults;
                             }
                         }
                         if (!token.IsCancellationRequested)
                         {
                             SearchResults = temp;
                             return SearchResults;
                         }

                     }
                 }

             }
             return new List<IDirectoryEntryAdapter>();
         });


    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
    }


}
