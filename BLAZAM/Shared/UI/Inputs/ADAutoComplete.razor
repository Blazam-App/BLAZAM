@inherits AutoCompleteComponentBase
<MudAutocomplete Class="@Class"
                 T="IDirectoryEntryAdapter"
                 Label="@Label"
                 @bind-Value="SelectedResult"
                 @bind-Text=@SearchTerm
                 SearchFuncWithCancel="@GetResults"
                  DebounceInterval=500
                 ResetValueOnEmptyText="true"
                 CoerceText="@AllowCustomInput" CoerceValue="false"
                 Clearable
                 ToStringFunc="item=>item?.CanonicalName"
                 AdornmentColor="Color.Secondary"
                 ProgressIndicatorColor="Color.Secondary"
                 Adornment="Adornment.Start"
                 AdornmentIcon="@Icons.Material.Filled.Search"
                 Variant="@Variant">
    <ItemTemplate>
        <MudText Typo="Typo.h5">
            @context?.ObjectType

            @if (context != null && context is IGroupableDirectoryAdapter gdm)
            {
                if (gdm.LockedOut)
                {

                    <MudBadge Color="Color.Warning">Locked</MudBadge>

                }
                if (!gdm.Enabled)
                {

                    <MudBadge Color="Color.Error">Disabled</MudBadge>

                }
            }




        </MudText>
        <MudText Typo="Typo.h6">
            <small>
                @context?.CanonicalName
            </small>

        </MudText>
        <MudText>
            <small>
                @context
            </small>
        </MudText>
    </ItemTemplate>
    <NoItemsTemplate>
        @if (SearchTerm.IsNullOrEmpty())
        {
            <MudText>

            Start typing to search...
            </MudText>

        }
        else
        {
            <MudText>
            Sorry no result were found 😒
            </MudText>

        }

        </NoItemsTemplate>
</MudAutocomplete>



@code {
#nullable disable warnings

    [Parameter]
    public string? Label { get; set; }
    [Parameter]
    public Variant Variant { get; set; }
    [Parameter]
    public string? Class { get; set; }
    [Parameter]
    public bool Multiple { get; set; }

    
    [Parameter]
    public bool AllowCustomInput { get; set; }


    [Parameter]
    public Func<IDirectoryEntryAdapter, bool> CustomResultsFilter { get; set; }
    @*
    [Parameter]
    public IFluentDisplay Display { get; set; }*@

    [CascadingParameter]
    public SearchService SearchParameters { get; set; }

    IEnumerable<IDirectoryEntryAdapter> _searchResults = new List<IDirectoryEntryAdapter>();
    bool _searchDisabled;
    [Parameter]
    public bool SearchDisabled
    {
        get => _searchDisabled;
        set
        {
            if (_searchDisabled == value)
                return;
            _searchDisabled = value;
            SearchDisabledChanged.InvokeAsync(value);
        }
    }


    [Parameter]
    public EventCallback<bool> SearchDisabledChanged { get; set; }


    [Parameter]
    public ActiveDirectoryObjectType? SearchObjectType { get; set; }


    [Parameter]
    public IEnumerable<IDirectoryEntryAdapter> SearchResults
    {
        get => _searchResults;
        set
        {
            if (_searchResults == value)
                return;
            _searchResults = value;
            SearchResultsChanged.InvokeAsync(value);
        }
    }


    [Parameter]
    public EventCallback<IEnumerable<IDirectoryEntryAdapter>> SearchResultsChanged { get; set; }

    public IDirectoryEntryAdapter _selectedResult;
    [Parameter]
    public IDirectoryEntryAdapter SelectedResult
    {
        get => _selectedResult;
        set
        {
            if (_selectedResult == value)
                return;
            SearchResults = new List<IDirectoryEntryAdapter>
                {
                    value
                };
            _selectedResult = value;
            SelectedResultChanged.InvokeAsync(value);
        }
    }

    [Parameter]
    public EventCallback<IDirectoryEntryAdapter> SelectedResultChanged { get; set; }





    public List<IDirectoryEntryAdapter> _selectedResults;

    //[Parameter]
    //public List<IDirectoryEntryAdapter> SelectedResults
    //{
    //    get => _selectedResults; set
    //    {
    //        if (_selectedResults == value) return;
    //        _selectedResults = value;
    //        SearchResults = value; //quesitnoable neccessity
    //        SelectedResultsChanged.InvokeAsync(value);
    //        SelectedResultNames = value.Select(g => g.CanonicalName).ToList();

    //        InvokeAsync(StateHasChanged);
    //    }
    //}

    //[Parameter]
    //public EventCallback<List<IDirectoryEntryAdapter>> SelectedResultsChanged { get; set; }

    List<string> SelectedResultNames = new();




    private async Task<IEnumerable<IDirectoryEntryAdapter>> GetResults(string searchText, CancellationToken token)
    {
        if (!token.IsCancellationRequested)
        {


            var search = new ADSearch();

            search.ObjectTypeFilter = SearchObjectType;
            search.GeneralSearchTerm = searchText.Replace(" ", "*");
            search.EnabledOnly = !SearchDisabled;
            search.MaxResults = 10;
            var temp = await search.SearchAsync();

            if (!token.IsCancellationRequested)
            {
                SearchResults = temp;

                if (CustomResultsFilter != null)
                {
                    List<IDirectoryEntryAdapter> filteredResults = new();
                    foreach (var result in SearchResults)
                    {
                        if (CustomResultsFilter.Invoke(result))
                            filteredResults.Add(result);
                    }
                    if (!token.IsCancellationRequested)
                    {
                        SearchResults = filteredResults;
                    }
                }
                return SearchResults;

            }

            /*
                        var temp = (await Directory.Users.FindUsersByStringAsync(autocompleteReadDataEventArgs.SearchValue.Replace(" ", "*"), enabledUsersOnly)).Where(u => u.CanRead);
                        if (!autocompleteReadDataEventArgs.CancellationToken.IsCancellationRequested)
                        {
                            SearchResults = temp;
                        }
                        */
        }
        return new List<IDirectoryEntryAdapter>();

    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        SearchDisabled = (bool)UserStateService.CurrentUserState?.UserSettings?.SearchDisabledUsers;
    }


}
