@inherits AutoCompleteComponentBase
<Autocomplete TItem="IDirectoryModel"
              TValue="IDirectoryModel"
              Data="@SearchResults"
              @bind-Search="SearchTerm"
              ReadData="@GetResults"
              TextField="@(( item ) => item.SamAccountName)"
              ValueField="@(( item ) => item)"
              @bind-SelectedValue="@SelectedResult"
              Placeholder="Search..."
              MinLength="1"
              Style=""
                FreeTyping>
    <ItemContent>
        <Div Padding="Padding.Is0" TextWeight="TextWeight.Bold">
            <Div Flex="Flex.InlineFlex">
                @context?.Value?.ObjectType

            </Div>
            @if (context?.Value != null && context.Value is IGroupableDirectoryModel gdm)
            {
                if (gdm.LockedOut)
                {

                    <Badge Flex=Flex.InlineFlex Float=Float.End Background="Background.Warning">Locked</Badge>

                }
                if (!gdm.Enabled)
                {

                    <Badge Flex=Flex.InlineFlex Float=Float.End Background="Background.Danger">Disabled</Badge>

                }
            }




        </Div>
        <Div Padding="Padding.Is0" TextWeight="TextWeight.Bold">
            <Small>
                @context?.Value?.CanonicalName
            </Small>

        </Div>
        <Div Padding="Padding.Is0">
            <Small>
                @context.Text
            </Small>
        </Div>
    </ItemContent>
    <NotFoundContent> Sorry... @context was not found! :( </NotFoundContent>
</Autocomplete>




@code {
    [CascadingParameter]
    public SearchService SearchParameters { get; set; }

    IEnumerable<IDirectoryModel> _searchResults = new List<IDirectoryModel>();
    bool _searchDisabled;
    [Parameter]
    public bool SearchDisabled
    {
        get => _searchDisabled;
        set
        {
            if (_searchDisabled == value)
                return;
            _searchDisabled = value;
            SearchDisabledChanged.InvokeAsync(value);
        }
    }


    [Parameter]
    public EventCallback<bool> SearchDisabledChanged { get; set; }


    [Parameter]
    public ActiveDirectoryObjectType? SearchObjectType { get; set; }


    [Parameter]
    public IEnumerable<IDirectoryModel> SearchResults
    {
        get => _searchResults;
        set
        {
            if (_searchResults == value)
                return;
            _searchResults = value;
            SearchResultsChanged.InvokeAsync(value);
        }
    }


    [Parameter]
    public EventCallback<IEnumerable<IDirectoryModel>> SearchResultsChanged { get; set; }

    public IDirectoryModel _selectedResult;
    [Parameter]
    public IDirectoryModel SelectedResult
    {
        get => _selectedResult;
        set
        {
            if (_selectedResult == value)
                return;
            SearchResults = new List<IDirectoryModel>
                {
                    value
                };
            _selectedResult = value;
            SelectedResultChanged.InvokeAsync(value);
        }
    }

    [Parameter]
    public EventCallback<IDirectoryModel> SelectedResultChanged { get; set; }

    private async Task GetResults(AutocompleteReadDataEventArgs autocompleteReadDataEventArgs)
    {
        if (!autocompleteReadDataEventArgs.CancellationToken.IsCancellationRequested)
        {


            var search = new ADSearch();

            search.ObjectTypeFilter = SearchObjectType;
            search.GeneralSearchTerm = autocompleteReadDataEventArgs.SearchValue.Replace(" ", "*");
            search.EnabledOnly = !SearchDisabled;
            search.MaxResults = 10;
            var temp = await search.SearchAsync();

            if (!autocompleteReadDataEventArgs.CancellationToken.IsCancellationRequested)
            {
                SearchResults = temp;
            }
            return;

            /*
                        var temp = (await Directory.Users.FindUsersByStringAsync(autocompleteReadDataEventArgs.SearchValue.Replace(" ", "*"), enabledUsersOnly)).Where(u => u.CanRead);
                        if (!autocompleteReadDataEventArgs.CancellationToken.IsCancellationRequested)
                        {
                            SearchResults = temp;
                        }
                        */
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        SearchDisabled = (bool)UserStateService.CurrentUserState?.UserSettings?.SearchDisabledUsers;
    }


}
